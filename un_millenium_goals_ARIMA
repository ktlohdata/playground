import pandas
import matplotlib.pyplot as plt

data = pandas.DataFrame.from_csv('TrainingSet.csv')
submissions = pandas.DataFrame.from_csv('SubmissionRows.csv')

ind = submissions.index.values

preddataset = pandas.DataFrame([])
for i in ind:
    preddataset = preddataset.append(data.loc[i])
    
# getting years
    
years = []
for i in data.columns.values:
    p = i.split(' ')
    years.append(p[0])
    
years = years[0:36]
years.append('Country Name')
years.append('Series Code')
years.append('Series Name')
preddataset.columns = years

preddataset.head()

## experimenting with ways of dealing with NA values ##
# dealing with NA values - ffill method

preddataset = preddataset.transpose()
preddataset = preddataset.fillna(method = 'ffill')
preddataset = preddataset.transpose()

preddataset.head()

preds = preddataset[preddataset.columns[0:36]]
preds.head()

# dealing with NA values - imputing method

from sklearn.preprocessing import Imputer
# split dataset into inputs and outputs
preds = preds.transpose()
values = preds.values
# fill missing values with mean column values
imputer = Imputer()
transformed_preds = imputer.fit_transform(preds)
transformed_preds = pandas.DataFrame(data = transformed_preds,columns = preds.columns.values,index = preds.index.values)

### full ARIMA model ###

from pandas import datetime
from pandas import DataFrame
from statsmodels.tsa.arima_model import ARIMA
from matplotlib import pyplot
from pandas import read_csv
from sklearn.metrics import mean_squared_error

preddata = preddataset[preddataset.columns[0:36]]
lst = list(preddata.transpose().columns.values)
preddata = preddata.transpose()

all_predictions = pandas.DataFrame(columns = ['2008 [YR2008]','2012 [YR2012]'])

for i in lst:
    try:
        p = pandas.DataFrame([])
        k = preddata[i]
        k = k.astype(float)
        k.index = pandas.to_datetime(k.index)
        k = pandas.DataFrame(k)
        k = k.reset_index(drop = False)
        k.columns = ['Year','Ind']
        k['Ind'] = k['Ind'].astype(float)
        k['Year'] = pandas.to_datetime(k['Year'])
        k = k.set_index('Year')

# getting predictions
        
        X = k.dropna().values
        size = int(len(X) - 5)
        train, test = X[0:size], X[size:len(X)]
        history = [x for x in train]
        predictions = list()
        for t in range(len(test)):
            model = ARIMA(history, order=(0,1,1))
            model_fit = model.fit(disp=0)
            output = model_fit.forecast()
            yhat = output[0]
            predictions.append(yhat)
            obs = test[t]
            history.append(obs)
            print('predicted=%f, expected=%f' % (yhat, obs))
        error = mean_squared_error(test, predictions)
        print('Test MSE: %.3f' % error)
        p['id'] = i
        p['2008 [YR2008]'] = predictions[0]
        p['2012 [YR2012]'] = predictions[4]
        p['id'] = str(i)
        p = p.set_index('id')
        del p.index.name
        all_predictions = all_predictions.append(p)
    except:
        pass

print all_predictions.head()
print len(all_predictions)

# check ids not predicted

not_predicted = []
for i in list(preddataset.index.values):
    if str(i) not in list(all_predictions.index.values):
        not_predicted.append(i)
        
# preddata[not_predicted[11]] - non-invertible issue

# dealing with remaining data points
for i in not_predicted:
    p['id'] = i
    p['2008 [YR2008]'] = preddata[i].loc['2007']
    p['2012 [YR2012]'] = preddata[i].loc['2007']
    p['id'] = str(i)
    p = p.set_index('id')
    del p.index.name
    all_predictions = all_predictions.append(p)

# sorting dataframe index

all_predictions.index = all_predictions.index.astype(int)
all_predictions = all_predictions.sort_index(ascending = True)

# print to csv
all_predictions.to_csv('predictions.csv',sep = ',')

# best so far: ARIMA(1,1,0) = differenced first-order autoregressive model
